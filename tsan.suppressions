# ThreadSanitizer suppressions for YAMS

# Boost.Asio experimental channel - known library limitation
# The channel_service uses null_mutex even when channel_traits<std::mutex> is specified
# This appears to be a boost library issue in versions < 1.85
race:boost::asio::experimental::detail::channel_service
race:channel_service.hpp

# Boost.Asio thread_info_base - thread-local storage cleanup race
# This is an internal boost::asio issue during thread destruction
race:boost::asio::detail::thread_info_base::deallocate

# Boost.Asio executor - internal race during coroutine dispatch
# This appears to be a timing issue in boost::asio's any_executor
race:boost::asio::execution::detail::any_executor_base::execute
race:any_executor.hpp

# Boost.Asio kqueue reactor descriptor mutex - upstream TSAN false positive when
# conditionally_enabled_mutex is reinitialized out of line with the reactor run
# loop (tracked upstream for Boost.Asio kqueue).
race:boost::asio::detail::conditionally_enabled_mutex
race:conditionally_enabled_mutex.hpp
race:kqueue_reactor.ipp

# Boost.Asio reactive socket service - race in socket descriptor registration
# when sockets are constructed/moved across threads. The reactor's internal
# fd_set_ tracking has a data race in reactive_socket_service_base::construct().
# This is a known boost::asio internal issue.
race:boost::asio::detail::reactive_socket_service_base::construct
race:reactive_socket_service_base.ipp
