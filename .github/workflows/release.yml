name: Release

on:
  push:
    tags:
      - "v*"
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: write

jobs:
  build-release:
    name: Build and Release (${{ matrix.os }})
    # Only run release if CI passed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: linux-self-hosted
            runs_on: '["self-hosted", "Linux", "X64"]'
            packaging: tgz
            cmake_args: ""
            suffix: linux-x86_64
            hosted: false
            build_packages: true
          - os: macos-self-hosted-arm64
            runs_on: '["self-hosted", "macOS", "ARM64"]'
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="arm64"
            suffix: macos-arm64
            hosted: false
          - os: macos-hosted-x64
            runs_on: '"macos-13"' # GitHub hosted Intel runner
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="x86_64"
            suffix: macos-x86_64
            hosted: true
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    env:
      BUILD_DIR: build/conan-release/build/Release
      STAGE_DIR: stage

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Ensure tags are available for git describe and version derivation
          fetch-depth: 0

      - name: Download CI benchmark artifacts (if available)
        if: github.event_name == 'workflow_run'
        uses: dawidd6/action-download-artifact@v6
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: benchmark-results-${{ matrix.os }}-conan
          path: ci-artifacts/benchmarks
          if_no_artifact_found: warn

      - name: Download CI coverage (if available)
        if: github.event_name == 'workflow_run' && matrix.os == 'linux-self-hosted'
        uses: dawidd6/action-download-artifact@v6
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: coverage-report
          path: ci-artifacts/coverage
          if_no_artifact_found: warn

      - name: Cache Conan packages
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: ~/.conan2/p
          key: conan-release-${{ runner.os }}-${{ matrix.suffix }}-${{ hashFiles('conan.lock', 'conanfile.py', 'CMakePresets.json') }}
          restore-keys: |
            conan-release-${{ runner.os }}-${{ matrix.suffix }}-
            conan-${{ runner.os }}-

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      # Hosted-only: install and configure Conan (self-hosted must already be configured)
      - name: Install Conan (hosted only)
        if: ${{ matrix.hosted }}
        shell: bash
        run: |
          pip3 install conan || python3 -m pip install conan || python -m pip install conan
          conan --version
          mkdir -p ~/.conan2
          # Best-effort: global.conf may not exist in repo for hosted macOS
          cp .conan/global.conf ~/.conan2/global.conf 2>/dev/null || true

      - name: Setup Conan Profile (hosted macOS)
        if: ${{ matrix.hosted && matrix.os == 'macos-hosted-x64' }}
        shell: bash
        run: |
          conan profile detect --force
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          else
            sed -i 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          fi
          echo "Conan profile configured:" >&2
          conan profile show >&2

      - name: Check Conan (self-hosted sanity)
        if: ${{ !matrix.hosted }}
        shell: bash
        run: conan --version || echo "Conan is expected to be pre-installed and configured on self-hosted runners"

      # Hosted-only: clean corrupted cache if needed
      - name: Clean corrupted Conan cache if needed (hosted only)
        if: ${{ matrix.hosted }}
        shell: bash
        run: |
          if ! conan list "*" 2>/dev/null; then
            echo "Conan cache appears corrupted, cleaning locks and temp files..."
            conan cache clean --locks --temp 2>/dev/null || true
            echo "Conan cache locks/temp cleaned"
          fi

      # Hosted-only: Validation build (tests + benchmarks)
      - name: Configure with Conan (Validation Build) [hosted only]
        if: ${{ matrix.hosted }}
        shell: bash
        run: |
          echo "Phase 1: Validation build with tests and benchmarks for ${{ matrix.suffix }}"
          conan install . \
            --output-folder=build/conan-validation \
            -s build_type=Release \
            --build=missing
          cmake -B build/conan-validation/build/Release -S . \
            -DCMAKE_TOOLCHAIN_FILE="$(pwd)/build/conan-validation/conan_toolchain.cmake" \
            -DYAMS_BUILD_TESTS=ON \
            -DYAMS_BUILD_BENCHMARKS=ON \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            ${{ matrix.cmake_args}}

      - name: Build and Test (Validation) [hosted only]
        if: ${{ matrix.hosted }}
        shell: bash
        run: |
          echo "Building with tests and benchmarks for validation..."
          cmake --build build/conan-validation/build/Release --parallel
          echo "Running tests..."
          cd build/conan-validation/build/Release/tests
          ctest --output-on-failure --timeout 300 || true
          cd "$GITHUB_WORKSPACE"
          echo "Validation complete, now building optimized release..."

      # Release build for ALL targets (self-hosted + hosted)
      - name: Configure and Build Release (Optimized)
        shell: bash
        run: |
          echo "Phase 2: Optimized release build for ${{ matrix.suffix }}"
          conan install . \
            --output-folder=build/conan-release \
            -s build_type=Release \
            --build=missing
          cmake --preset conan-release \
            -DYAMS_BUILD_PROFILE=release \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            -DCMAKE_INSTALL_PREFIX="$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}" \
            ${{ matrix.cmake_args}}
          cmake --build --preset conan-release --parallel
          echo "BUILD_DIR=build/conan-release/build/Release" >> $GITHUB_ENV

      - name: Collect benchmark results
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"
          # Collect from validation build
          if [ -f "build/conan-validation/build/Release/bench_results.json" ]; then
            cp build/conan-validation/build/Release/bench_results.json "$BUILD_DIR/bench_results/"
            echo "Collected benchmark results from validation build"
          fi
          # Also check CI artifacts if available
          if [ -d "ci-artifacts/benchmarks" ] && [ "$(ls -A ci-artifacts/benchmarks/*.json 2>/dev/null)" ]; then
            cp ci-artifacts/benchmarks/*.json "$BUILD_DIR/bench_results/" || true
          fi

      - name: Install
        shell: bash
        run: |
          # Ensure BUILD_DIR is properly set
          if [ ! -d "$BUILD_DIR" ]; then
            echo "BUILD_DIR not found at $BUILD_DIR, checking for alternative..."
            if [ -d "build/conan-release/build/Release" ]; then
              BUILD_DIR="build/conan-release/build/Release"
              echo "Using BUILD_DIR: $BUILD_DIR"
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
            fi
          fi
          cmake --install "$BUILD_DIR" --config Release

      - name: Generate release summary
        shell: bash
        run: |
          SUMMARY_FILE="$BUILD_DIR/release_summary.md"
          echo "## Release Build Information (v${{ steps.v.outputs.version }})" > "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          echo "**Platform:** ${{ matrix.suffix }}" >> "$SUMMARY_FILE"
          echo "**Build Type:** Release" >> "$SUMMARY_FILE"

          # Only mention CI validation if we actually have CI artifacts
          if [ -d "ci-artifacts" ] && [ "$(ls -A ci-artifacts/ 2>/dev/null)" ]; then
            echo "**CI Status:** Tests and benchmarks from CI workflow" >> "$SUMMARY_FILE"
          fi
          echo "" >> "$SUMMARY_FILE"

          # Add coverage information if available
          if [ -f "ci-artifacts/coverage/coverage.xml" ]; then
            echo "### Test Coverage" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            coverage_pct=$(python3 <<'PY' 2>/dev/null || echo 'N/A'
          import xml.etree.ElementTree as ET
          try:
              root = ET.parse('ci-artifacts/coverage/coverage.xml').getroot()
              line_rate = float(root.get('line-rate', 0))
              print(f"{line_rate * 100:.1f}%")
          except Exception:
              print('N/A')
          PY
            )
            echo "**Line Coverage:** $coverage_pct" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
          fi

          # Add benchmark results if available from CI or validation
          if [ -d "$BUILD_DIR/bench_results" ] && [ "$(find $BUILD_DIR/bench_results -name '*.json' 2>/dev/null)" ]; then
            echo "### Performance Metrics" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "| Benchmark | Time (ns/op) | CPU (ns/op) | Memory |" >> "$SUMMARY_FILE"
            echo "|-----------|--------------|-------------|--------|" >> "$SUMMARY_FILE"

            for json_file in "$BUILD_DIR/bench_results"/*.json; do
              if [ -f "$json_file" ]; then
                python3 - "$json_file" <<'PY' 2>/dev/null >> "$SUMMARY_FILE" || true
          import json, sys
          try:
              path = sys.argv[1]
              with open(path) as f:
                  data = json.load(f)
                  if 'benchmarks' in data:
                      for bench in data['benchmarks']:
                          name = bench.get('name', 'Unknown')
                          real_time = bench.get('real_time', 0.0)
                          cpu_time = bench.get('cpu_time', 0.0)
                          bytes_per_sec = bench.get('bytes_per_second', 0.0)
                          items_per_sec = bench.get('items_per_second', 0.0)
                          memory = f"{bytes_per_sec/1024/1024:.1f} MB/s" if bytes_per_sec > 0 else (f"  {items_per_sec:.0f} ops/s" if items_per_sec > 0 else "N/A")
                          print(f"| {name} | {real_time:.0f} | {cpu_time:.0f} | {memory} |")
          except Exception:
              pass
          PY
              fi
            done
            echo "" >> "$SUMMARY_FILE"
          fi

          echo "Generated release summary at: $SUMMARY_FILE"
          cat "$SUMMARY_FILE"

      - name: Package
        id: pkg
        shell: bash
        run: |
          cd "$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}"
          VERSION="${{ steps.v.outputs.version }}"
          SUFFIX="${{ matrix.suffix }}"
          OUTDIR="$GITHUB_WORKSPACE"
          if [ "${{ matrix.packaging }}" = "zip" ]; then
            ASSET="yams-${VERSION}-${SUFFIX}.zip"
            zip -r "$OUTDIR/$ASSET" .
          else
            ASSET="yams-${VERSION}-${SUFFIX}.tar.gz"
            tar czf "$OUTDIR/$ASSET" .
          fi
          echo "asset_path=$OUTDIR/$ASSET" >> "$GITHUB_OUTPUT"
          echo "Created asset: $OUTDIR/$ASSET"

      - name: Build Linux packages (DEB/RPM)
        if: matrix.build_packages == true && matrix.os == 'linux-self-hosted'
        shell: bash
        run: |
          cd "$BUILD_DIR"
          VERSION="${{ steps.v.outputs.version }}"
          
          # Generate DEB package
          cpack -G DEB -D CPACK_PACKAGE_VERSION="${VERSION}"
          DEB_FILE=$(ls *.deb 2>/dev/null | head -1)
          if [ -n "$DEB_FILE" ]; then
            mv "$DEB_FILE" "$GITHUB_WORKSPACE/yams-${VERSION}-amd64.deb"
            echo "Created DEB package: yams-${VERSION}-amd64.deb"
          fi
          
          # Generate RPM package
          if command -v rpmbuild >/dev/null 2>&1; then
            cpack -G RPM -D CPACK_PACKAGE_VERSION="${VERSION}"
            RPM_FILE=$(ls *.rpm 2>/dev/null | head -1)
            if [ -n "$RPM_FILE" ]; then
              mv "$RPM_FILE" "$GITHUB_WORKSPACE/yams-${VERSION}-x86_64.rpm"
              echo "Created RPM package: yams-${VERSION}-x86_64.rpm"
            fi
          else
            echo "rpmbuild not found, skipping RPM generation"
          fi
          
          # Generate AppImage if appimage-builder is available
          if command -v appimage-builder >/dev/null 2>&1; then
            cd "$GITHUB_WORKSPACE"
            cp packaging/appimage/AppImageBuilder.yml .
            export YAMS_VERSION="${VERSION}"
            appimage-builder --skip-tests || echo "AppImage build failed, skipping"
            APPIMAGE_FILE=$(ls YAMS-*.AppImage 2>/dev/null | head -1)
            if [ -n "$APPIMAGE_FILE" ]; then
              mv "$APPIMAGE_FILE" "yams-${VERSION}-x86_64.AppImage"
              echo "Created AppImage: yams-${VERSION}-x86_64.AppImage"
            fi
          else
            echo "appimage-builder not found, skipping AppImage generation"
          fi

      - name: Combine release notes with build information
        shell: bash
        run: |
          COMBINED_NOTES="$BUILD_DIR/combined_release_notes.md"
          echo "${{ steps.changelog.outputs.release_notes }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add release summary if it exists
          if [ -f "$BUILD_DIR/release_summary.md" ]; then
            cat "$BUILD_DIR/release_summary.md" >> "$COMBINED_NOTES"
          fi

          echo "Combined release notes:"
          cat "$COMBINED_NOTES"

      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.suffix }}
          path: |
            ${{ steps.pkg.outputs.asset_path }}
            ${{ env.BUILD_DIR }}/release_summary.md
            ${{ env.BUILD_DIR }}/bench_results/*.json
            yams-*.deb
            yams-*.rpm
            yams-*.AppImage
          retention-days: 1

  create-release:
    name: Create GitHub Release
    needs: build-release
    runs-on: ubuntu-latest
    if: success()
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts
          pattern: release-*

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p assets
          # Collect all release files
          for dir in release-artifacts/release-*; do
            if [ -d "$dir" ]; then
              # Move main archive
              mv $dir/*.{tar.gz,zip} assets/ 2>/dev/null || true
              # Move Linux packages
              mv $dir/*.deb assets/ 2>/dev/null || true
              mv $dir/*.rpm assets/ 2>/dev/null || true
              mv $dir/*.AppImage assets/ 2>/dev/null || true
              # Collect benchmark results
              cp $dir/bench_results/*.json assets/ 2>/dev/null || true
            fi
          done
          echo "Collected assets:"
          ls -la assets/

      - name: Combine release notes
        shell: bash
        run: |
          COMBINED_NOTES="combined_release_notes.md"
          echo "${{ steps.changelog.outputs.release_notes }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"
          echo "## Platform Builds" >> "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"
          # Add summaries from each platform
          for summary in release-artifacts/release-*/release_summary.md; do
            if [ -f "$summary" ]; then
              platform=$(basename $(dirname "$summary") | sed 's/release-//')
              echo "### $platform" >> "$COMBINED_NOTES"
              tail -n +2 "$summary" >> "$COMBINED_NOTES"
              echo "" >> "$COMBINED_NOTES"
            fi
          done

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: YAMS ${{ steps.v.outputs.version }}
          body_path: combined_release_notes.md
          files: assets/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
