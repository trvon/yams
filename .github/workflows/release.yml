name: Release

on:
  push:
    tags:
      - "v*"
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: write

jobs:
  build-release:
    name: Build and Release (${{ matrix.os }})
    # Only run release if CI passed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
    strategy:
      fail-fast: false
      matrix:
         # Note: Validation (tests + benchmarks) runs only on linux-hosted
         # Other platforms do optimized release builds only
         include:
           - os: linux-hosted
             runs_on: "ubuntu-latest"
             packaging: tgz
             cmake_args: ""
             suffix: linux-x86_64
             hosted: true
             build_packages: true
           - os: macos-hosted-arm64
             runs_on: "macos-14"
             packaging: zip
             cmake_args: -DCMAKE_OSX_ARCHITECTURES="arm64"
             suffix: macos-arm64
             hosted: true
             build_packages: true
           - os: macos-hosted-x64
             runs_on: "macos-13" # GitHub hosted Intel runner
             packaging: zip
             cmake_args: -DCMAKE_OSX_ARCHITECTURES="x86_64"
             suffix: macos-x86_64
             hosted: true
           - os: windows-hosted-x64
             runs_on: "windows-2022"
             packaging: zip
             cmake_args: ""
             suffix: windows-x86_64
             hosted: true
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    env:
      BUILD_DIR: build/yams-release
      STAGE_DIR: stage

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Ensure tags are available for git describe and version derivation
          fetch-depth: 0

      - name: Download CI benchmark artifacts (-yams, if available)
        if: github.event_name == 'workflow_run'
        uses: dawidd6/action-download-artifact@v6
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: benchmark-results-${{ matrix.os }}-yams
          path: ci-artifacts/benchmarks
          if_no_artifact_found: warn

      - name: Download CI benchmark artifacts (legacy -conan, fallback)
        if: github.event_name == 'workflow_run'
        uses: dawidd6/action-download-artifact@v6
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: benchmark-results-${{ matrix.os }}-conan
          path: ci-artifacts/benchmarks
          if_no_artifact_found: warn

      - name: Download CI coverage (if available)
        if: github.event_name == 'workflow_run' && matrix.os == 'linux-hosted'
        uses: dawidd6/action-download-artifact@v6
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: coverage-report
          path: ci-artifacts/coverage
          if_no_artifact_found: warn

      - name: Cache Conan packages
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: ~/.conan2/p
          key: yams-release-${{ runner.os }}-${{ matrix.suffix }}-${{ hashFiles('conan.lock', 'conanfile.py', 'CMakePresets.json') }}
          restore-keys: |
            yams-release-${{ runner.os }}-${{ matrix.suffix }}-
            yams-${{ runner.os }}-

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      # Hosted runners: install and configure Conan (self-hosted must already be configured)
      - name: Install Conan (hosted only)
        if: ${{ matrix.hosted && !startsWith(matrix.os, 'windows') }}
        shell: bash
        run: |
          pip3 install conan || python3 -m pip install conan || python -m pip install conan
          conan --version
          mkdir -p ~/.conan2
          # Best-effort: global.conf may not exist in repo for hosted macOS
          cp .conan/global.conf ~/.conan2/global.conf 2>/dev/null || true

      - name: Setup Conan Profile (hosted macOS)
        if: ${{ matrix.hosted && matrix.os == 'macos-hosted-x64' }}
        shell: bash
        run: |
          conan profile detect --force
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          else
            sed -i 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          fi
          echo "Conan profile configured:" >&2
          conan profile show >&2

      - name: Setup Python (hosted Windows)
        if: ${{ matrix.hosted && startsWith(matrix.os, 'windows') }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install Conan (hosted Windows)
        if: ${{ matrix.hosted && startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          python -m pip install --user pipx
          python -m pipx ensurepath
          try {
            pipx install conan --force
          } catch {
            Write-Host "pipx install failed; falling back to pip"
            python -m pip install --upgrade conan
          }
          $scriptDir = "$env:PythonLocation\Scripts"
          $localBin = "$env:USERPROFILE\.local\bin"
          $env:PATH = "$localBin;$scriptDir;$env:PATH"
          "$localBin" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          "$scriptDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          conan --version

      - name: Setup Conan Profile (hosted Windows)
        if: ${{ matrix.hosted && startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          conan profile detect --force
          conan profile update "settings.compiler.cppstd=20" default
          conan profile show

      - name: Check Conan (self-hosted sanity)
        if: ${{ !matrix.hosted }}
        shell: bash
        run: conan --version || echo "Conan is expected to be pre-installed and configured on self-hosted runners"

      # Hosted runners: clean corrupted cache if needed
      - name: Clean corrupted Conan cache if needed (hosted only)
        if: ${{ matrix.hosted }}
        shell: bash
        run: |
          if ! conan list "*" 2>/dev/null; then
            echo "Conan cache appears corrupted, cleaning locks and temp files..."
            conan cache clean --locks --temp 2>/dev/null || true
            echo "Conan cache locks/temp cleaned"
          fi

      # Linux hosted only: Validation build (tests + benchmarks)
      - name: Configure with Conan (Validation Build) [Linux hosted only]
        if: ${{ matrix.os == 'linux-hosted' }}
        continue-on-error: true
        shell: bash
        run: |
          echo "Phase 1: Validation build with tests and benchmarks on Linux"
          # Clean any existing build directory and presets to avoid duplicate preset issues
          rm -rf build/yams-release
          rm -f CMakeUserPresets.json
          conan install . \
            --output-folder=build/yams-release \
            -s build_type=Release \
            -o build_tests=True \
            -o build_benchmarks=True \
            --build=missing
          cmake --preset yams-release \
            -DYAMS_BUILD_TESTS=ON \
            -DYAMS_BUILD_BENCHMARKS=ON \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            ${{ matrix.cmake_args}}

      - name: Build and Test (Validation) [Linux hosted only]
        if: ${{ matrix.os == 'linux-hosted' }}
        continue-on-error: true
        shell: bash
        run: |
          echo "Building with tests and benchmarks for validation..."
          cmake --build --preset yams-release --parallel
          echo "Running tests..."
          # Skip slow model loading tests in CI to prevent timeouts
          YAMS_SKIP_SLOW_TESTS=1 ctest --preset test-yams-release --output-on-failure --timeout 300 || true
          echo "Validation complete, now building optimized release..."

      # Release build for ALL targets
      - name: Configure and Build Release (Optimized)
        if: ${{ !startsWith(matrix.os, 'windows') }}
        shell: bash
        run: |
          echo "Optimized release build for ${{ matrix.suffix }}"
          # Clean any existing build directory and presets to avoid duplicate preset issues
          rm -rf build/yams-release
          rm -f CMakeUserPresets.json
          conan install . \
            --output-folder=build/yams-release \
            -s build_type=Release \
            --build=missing
          cmake --preset yams-release \
            -DYAMS_BUILD_PROFILE=release \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            -DCMAKE_INSTALL_PREFIX="$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}" \
            ${{ matrix.cmake_args}}
          cmake --build --preset yams-release --parallel
          echo "BUILD_DIR=build/yams-release" >> $GITHUB_ENV

      - name: Configure and Build Release (Optimized) [Windows]
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          Write-Host "Optimized release build for ${{ matrix.suffix }}"
          Remove-Item -Recurse -Force build\yams-release -ErrorAction SilentlyContinue
          Remove-Item -Force CMakeUserPresets.json -ErrorAction SilentlyContinue

          # Ensure Conan is available (pipx first, fallback to pip), and update PATH
          python -m pip install --upgrade pip
          python -m pip install --user pipx
          python -m pipx ensurepath
          try {
            pipx install conan --force
          } catch {
            Write-Host "pipx install failed; falling back to pip"
            python -m pip install --upgrade conan
          }
          $scriptDir = "$env:PythonLocation\Scripts"
          $localBin = "$env:USERPROFILE\.local\bin"
          $env:PATH = "$localBin;$scriptDir;$env:PATH"
          "$localBin" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          "$scriptDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          conan --version

          conan install . `
            --output-folder=build/yams-release `
            -s build_type=Release `
            --build=missing

          cmake --preset yams-release `
            -DYAMS_BUILD_PROFILE=release `
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" `
            -DCMAKE_INSTALL_PREFIX="${{ github.workspace }}\${{ env.STAGE_DIR }}" `
            ${{ matrix.cmake_args }}

          cmake --build --preset build-yams-release --parallel

          "BUILD_DIR=build/yams-release" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii

      - name: Collect benchmark results
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"
          # Collect from validation build (if Linux hosted ran validation)
          if [ -f "build/yams-release/bench_results.json" ]; then
            cp build/yams-release/bench_results.json "$BUILD_DIR/bench_results/"
            echo "Collected benchmark results from validation build"
          fi
          # Also check CI artifacts if available
          if [ -d "ci-artifacts/benchmarks" ] && [ "$(ls -A ci-artifacts/benchmarks/*.json 2>/dev/null)" ]; then
            cp ci-artifacts/benchmarks/*.json "$BUILD_DIR/bench_results/" || true
          fi

      - name: Install
        shell: bash
        run: |
          # Ensure BUILD_DIR is properly set
          if [ ! -d "$BUILD_DIR" ]; then
            echo "BUILD_DIR not found at $BUILD_DIR, checking for alternative..."
            if [ -d "build/yams-release" ]; then
              BUILD_DIR="build/yams-release"
              echo "Using BUILD_DIR: $BUILD_DIR"
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
            fi
          fi
          cmake --install "$BUILD_DIR" --config Release

      - name: Generate release summary
        shell: bash
        run: |
          SUMMARY_FILE="$BUILD_DIR/release_summary.md"
          echo "## Release Build Information (v${{ steps.v.outputs.version }})" > "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          echo "**Platform:** ${{ matrix.suffix }}" >> "$SUMMARY_FILE"
          echo "**Build Type:** Release" >> "$SUMMARY_FILE"

          # Only mention CI validation if we actually have CI artifacts
          if [ -d "ci-artifacts" ] && [ "$(ls -A ci-artifacts/ 2>/dev/null)" ]; then
            echo "**CI Status:** Tests and benchmarks from CI workflow" >> "$SUMMARY_FILE"
          fi
          echo "" >> "$SUMMARY_FILE"

          # Add coverage information if available
          if [ -f "ci-artifacts/coverage/coverage.xml" ]; then
            echo "### Test Coverage" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            coverage_pct=$(python3 <<'PY' 2>/dev/null || echo 'N/A'
              import xml.etree.ElementTree as ET
              try:
                  root = ET.parse('ci-artifacts/coverage/coverage.xml').getroot()
                  line_rate = float(root.get('line-rate', 0))
                  print(f"{line_rate * 100:.1f}%")
              except Exception:
                  print('N/A')
              PY
            )
            echo "**Line Coverage:** $coverage_pct" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
          fi

          # Add benchmark results if available from CI or validation
          if [ -d "$BUILD_DIR/bench_results" ] && [ "$(find $BUILD_DIR/bench_results -name '*.json' 2>/dev/null)" ]; then
            echo "### Performance Metrics" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "| Benchmark | Time (ns/op) | CPU (ns/op) | Memory |" >> "$SUMMARY_FILE"
            echo "|-----------|--------------|-------------|--------|" >> "$SUMMARY_FILE"

            for json_file in "$BUILD_DIR/bench_results"/*.json; do
              if [ -f "$json_file" ]; then
                python3 - "$json_file" <<'PY' 2>/dev/null >> "$SUMMARY_FILE" || true
                  import json, sys
                  try:
                      path = sys.argv[1]
                      with open(path) as f:
                          data = json.load(f)
                          if 'benchmarks' in data:
                              for bench in data['benchmarks']:
                                  name = bench.get('name', 'Unknown')
                                  real_time = bench.get('real_time', 0.0)
                                  cpu_time = bench.get('cpu_time', 0.0)
                                  bytes_per_sec = bench.get('bytes_per_second', 0.0)
                                  items_per_sec = bench.get('items_per_second', 0.0)
                                  memory = f"{bytes_per_sec/1024/1024:.1f} MB/s" if bytes_per_sec > 0 else (f"  {items_per_sec:.0f} ops/s" if items_per_sec > 0 else "N/A")
                                  print(f"| {name} | {real_time:.0f} | {cpu_time:.0f} | {memory} |")
                  except Exception:
                      pass
                  PY
              fi
            done
            echo "" >> "$SUMMARY_FILE"
          fi

          echo "Generated release summary at: $SUMMARY_FILE"
          cat "$SUMMARY_FILE"

      - name: Package
        if: ${{ !startsWith(matrix.os, 'windows') }}
        shell: bash
        run: |
          cd "$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}"
          VERSION="${{ steps.v.outputs.version }}"
          SUFFIX="${{ matrix.suffix }}"
          OUTDIR="$GITHUB_WORKSPACE"
          if [ "${{ matrix.packaging }}" = "zip" ]; then
            ASSET="yams-${VERSION}-${SUFFIX}.zip"
            zip -r "$OUTDIR/$ASSET" .
          else
            ASSET="yams-${VERSION}-${SUFFIX}.tar.gz"
            tar czf "$OUTDIR/$ASSET" .
          fi
          echo "ASSET_PATH=$OUTDIR/$ASSET" >> "$GITHUB_ENV"
          echo "Created asset: $OUTDIR/$ASSET"

      - name: Package (Windows)
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          $stage = "${{ github.workspace }}\${{ env.STAGE_DIR }}"
          $version = "${{ steps.v.outputs.version }}"
          $suffix = "${{ matrix.suffix }}"
          $out = "${{ github.workspace }}\yams-$version-$suffix.zip"
          if (Test-Path $out) { Remove-Item $out -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $out
          "ASSET_PATH=$out" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Created asset: $out"

      - name: Build Linux packages (DEB/RPM)
        if: matrix.build_packages == true && matrix.os == 'linux-hosted'
        shell: bash
        run: |
          cd "$BUILD_DIR"
          VERSION="${{ steps.v.outputs.version }}"

          # Generate DEB package
          cpack -G DEB -D CPACK_PACKAGE_VERSION="${VERSION}"
          DEB_FILE=$(ls *.deb 2>/dev/null | head -1)
          if [ -n "$DEB_FILE" ]; then
            mv "$DEB_FILE" "$GITHUB_WORKSPACE/yams-${VERSION}-amd64.deb"
            echo "Created DEB package: yams-${VERSION}-amd64.deb"
          fi

          # Generate RPM package
          if command -v rpmbuild >/dev/null 2>&1; then
            cpack -G RPM -D CPACK_PACKAGE_VERSION="${VERSION}"
            RPM_FILE=$(ls *.rpm 2>/dev/null | head -1)
            if [ -n "$RPM_FILE" ]; then
              mv "$RPM_FILE" "$GITHUB_WORKSPACE/yams-${VERSION}-x86_64.rpm"
              echo "Created RPM package: yams-${VERSION}-x86_64.rpm"
            fi
          else
            echo "rpmbuild not found, skipping RPM generation"
          fi

          # Generate AppImage if appimage-builder is available
          if command -v appimage-builder >/dev/null 2>&1; then
            cd "$GITHUB_WORKSPACE"
            cp packaging/appimage/AppImageBuilder.yml .
            export YAMS_VERSION="${VERSION}"
            appimage-builder --skip-tests || echo "AppImage build failed, skipping"
            APPIMAGE_FILE=$(ls YAMS-*.AppImage 2>/dev/null | head -1)
            if [ -n "$APPIMAGE_FILE" ]; then
              mv "$APPIMAGE_FILE" "yams-${VERSION}-x86_64.AppImage"
              echo "Created AppImage: yams-${VERSION}-x86_64.AppImage"
            fi
          else
            echo "appimage-builder not found, skipping AppImage generation"
          fi

      - name: Combine release notes with build information
        shell: bash
        run: |
          COMBINED_NOTES="$BUILD_DIR/combined_release_notes.md"
          echo "${{ steps.changelog.outputs.release_notes }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add release summary if it exists
          if [ -f "$BUILD_DIR/release_summary.md" ]; then
            cat "$BUILD_DIR/release_summary.md" >> "$COMBINED_NOTES"
          fi

          echo "Combined release notes:"
          cat "$COMBINED_NOTES"

      - name: Publish matrix.json (expected platform count)
        shell: bash
        run: |
          echo '{"total": 4}' > matrix.json

      - name: Upload matrix metadata
        uses: actions/upload-artifact@v4
        with:
          name: matrix
          path: matrix.json
          retention-days: 1

      - name: Upload Release Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.suffix }}
          path: |
            yams-*.tar.gz
            yams-*.zip
            ${{ env.BUILD_DIR }}/release_summary.md
            ${{ env.BUILD_DIR }}/bench_results/*.json
            yams-*.deb
            yams-*.rpm
            yams-*.AppImage
          retention-days: 1

  create-release:
    name: Create GitHub Release
    needs: build-release
    runs-on: ubuntu-latest
    # Run unconditionally; dynamic threshold enforced inside the job
    if: always() && !cancelled()
    permissions:
      contents: write
      actions: read
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts
          pattern: "*"
      - name: Check job completion status
        id: check-status
        shell: bash
        run: |
          # Discover expected platforms from matrix job names in this run
          JOBS_JSON=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                           -H "Accept: application/vnd.github.v3+json" \
                           -s "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100")
          # Extract unique platform identifiers from "Build and Release (<platform>)" job names
          EXPECTED_PLATFORMS=$(echo "$JOBS_JSON" | sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\(Build and Release ([^"]*)\)".*/\1/p' | sed -n 's/Build and Release (\(.*\))/\1/p' | sort -u)
          TOTAL_EXPECTED=$(echo "$EXPECTED_PLATFORMS" | grep -c . || true)

          # Count successful artifacts from downloaded files (release-*)
          if [ -d "release-artifacts" ]; then
            # Count per-platform artifact directories (robust against file/dir listing quirks)
            SUCCESS_COUNT=$(find "release-artifacts" -mindepth 1 -maxdepth 1 -type d -name 'release-*' 2>/dev/null | grep -c . || true)
          else
            SUCCESS_COUNT=0
          fi

          # Determine expected builds:
          # 1) Prefer matrix.json (if provided)
          # 2) Otherwise, fall back to number of artifact groups downloaded
          if [ -f "release-artifacts/matrix.json" ]; then
            TOTAL_EXPECTED=$(cat "release-artifacts/matrix.json" | tr -d '\r' | grep -Eo '"total"[[:space:]]*:[[:space:]]*[0-9]+' | grep -Eo '[0-9]+' | head -1)
          fi
          if [ -z "$TOTAL_EXPECTED" ] || [ "$TOTAL_EXPECTED" -eq 0 ]; then
            TOTAL_EXPECTED="$SUCCESS_COUNT"
          fi

          # Compute dynamic threshold = ceil(TOTAL_EXPECTED / 2)
          THRESHOLD=$(( (TOTAL_EXPECTED + 1) / 2 ))

          echo "Successful builds: $SUCCESS_COUNT out of $TOTAL_EXPECTED (threshold: $THRESHOLD)"

          if [ "$SUCCESS_COUNT" -lt "$THRESHOLD" ]; then
            echo "ERROR: Need at least $THRESHOLD successful builds to create release (out of $TOTAL_EXPECTED expected)"
            exit 1
          fi

          echo "success_count=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "total_expected=$TOTAL_EXPECTED" >> $GITHUB_OUTPUT
          echo "threshold=$THRESHOLD" >> $GITHUB_OUTPUT

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      - name: Extract grouped changelogs for minor version
        id: grouped-changelog
        shell: bash
        run: |
          # Extract minor version from current tag
          CURRENT_VERSION="${{ steps.v.outputs.version }}"
          MINOR_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/^v?([0-9]+\.[0-9]+).*/\1/')

          echo "Current version: $CURRENT_VERSION"
          echo "Extracting all changes for minor version: $MINOR_VERSION"

          # Create grouped changelog file
          GROUPED_FILE="grouped_changelog_${MINOR_VERSION}.md"

          # Extract all entries for this minor version from CHANGELOG.md
          echo "# Release Notes for v${MINOR_VERSION}.x Series" > "$GROUPED_FILE"
          echo "" >> "$GROUPED_FILE"
          echo "This release is part of the v${MINOR_VERSION}.x series. Below are all changes in this series:" >> "$GROUPED_FILE"
          echo "" >> "$GROUPED_FILE"

          # Parse CHANGELOG.md and extract all sections matching the minor version
          awk -v minor="$MINOR_VERSION" '
            /^## \[v?[0-9]+\.[0-9]+\.[0-9]+/ {
              # Extract version parts using simpler approach
              version_str = $2
              gsub(/\[v?/, "", version_str)
              gsub(/\]/, "", version_str)
              split(version_str, version_parts, ".")
              version_minor = version_parts[1] "." version_parts[2]

              if (version_minor == minor) {
                in_section = 1
                print $0
                next
              } else {
                in_section = 0
              }
            }
            /^## \[/ && in_section { in_section = 0 }
            in_section { print }
          ' CHANGELOG.md >> "$GROUPED_FILE"

          # Store path for later use
          echo "grouped_changelog_file=$GROUPED_FILE" >> $GITHUB_OUTPUT
          echo "minor_version=$MINOR_VERSION" >> $GITHUB_OUTPUT

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p assets
          # Collect all release files
          for dir in release-artifacts/release-*; do
            if [ -d "$dir" ]; then
              # Move main archive
              mv $dir/*.{tar.gz,zip} assets/ 2>/dev/null || true
              # Move Linux packages
              mv $dir/*.deb assets/ 2>/dev/null || true
              mv $dir/*.rpm assets/ 2>/dev/null || true
              mv $dir/*.AppImage assets/ 2>/dev/null || true
              # Collect benchmark results
              cp $dir/bench_results/*.json assets/ 2>/dev/null || true
            fi
          done
          echo "Collected assets:"
          ls -la assets/

      - name: Combine release notes
        shell: bash
        run: |
          COMBINED_NOTES="combined_release_notes.md"

          # Start with current version changes
          echo "# YAMS ${{ steps.v.outputs.version }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"
          echo "${{ steps.changelog.outputs.release_notes }}" >> "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add platform build status
          echo "## Platform Builds" >> "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"
          echo "Successfully built for ${{ steps.check-status.outputs.success_count }} out of ${{ steps.check-status.outputs.total_expected }} platforms:" >> "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add summaries from each platform
          for summary in release-artifacts/release-*/release_summary.md; do
            if [ -f "$summary" ]; then
              platform=$(basename $(dirname "$summary") | sed 's/release-//')
              echo "### ✅ $platform" >> "$COMBINED_NOTES"
              tail -n +2 "$summary" >> "$COMBINED_NOTES"
              echo "" >> "$COMBINED_NOTES"
            fi
          done

          # List missing platforms if any
          if [ "${{ steps.check-status.outputs.success_count }}" -lt "3" ]; then
            echo "### ⚠️ Missing Platforms" >> "$COMBINED_NOTES"
            echo "" >> "$COMBINED_NOTES"
            echo "Some platforms failed to build. They may be added in a future patch release." >> "$COMBINED_NOTES"
            echo "" >> "$COMBINED_NOTES"
          fi

          # Add series changelog if not a patch 0 release
          PATCH_VERSION=$(echo "${{ steps.v.outputs.version }}" | sed -E 's/^v?[0-9]+\.[0-9]+\.([0-9]+).*/\1/')
          if [ "$PATCH_VERSION" != "0" ]; then
            echo "---" >> "$COMBINED_NOTES"
            echo "" >> "$COMBINED_NOTES"
            echo "## All Changes in v${{ steps.grouped-changelog.outputs.minor_version }}.x Series" >> "$COMBINED_NOTES"
            echo "" >> "$COMBINED_NOTES"
            echo "<details>" >> "$COMBINED_NOTES"
            echo "<summary>Click to expand full series changelog</summary>" >> "$COMBINED_NOTES"
            echo "" >> "$COMBINED_NOTES"
            # Include grouped changelog content
            if [ -f "${{ steps.grouped-changelog.outputs.grouped_changelog_file }}" ]; then
              tail -n +4 "${{ steps.grouped-changelog.outputs.grouped_changelog_file }}" >> "$COMBINED_NOTES"
            fi
            echo "" >> "$COMBINED_NOTES"
            echo "</details>" >> "$COMBINED_NOTES"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: YAMS ${{ steps.v.outputs.version }}
          body_path: combined_release_notes.md
          files: assets/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
