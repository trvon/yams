name: Release

on:
  push:
    tags:
      - "v*"
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: write

jobs:
  build-release:
    name: Build and Release (${{ matrix.os }})
    # Only run release if CI passed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: linux-self-hosted
            runs_on: '["self-hosted", "Linux", "X64"]'
            packaging: tgz
            cmake_args: ""
            suffix: linux-x86_64
          - os: macos-self-hosted-arm64
            runs_on: '["self-hosted", "macOS", "ARM64"]'
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="arm64"
            suffix: macos-arm64
          - os: macos-hosted-x64
            runs_on: '"macos-13"' # GitHub hosted Intel runner
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="x86_64"
            suffix: macos-x86_64
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    env:
      BUILD_DIR: build/conan-release/build/Release
      STAGE_DIR: stage
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Ensure tags are available for git describe and version derivation
          fetch-depth: 0

      - name: Download CI benchmark artifacts (if available)
        if: github.event_name == 'workflow_run'
        uses: dawidd6/action-download-artifact@v11
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: benchmark-results-${{ matrix.os }}-conan
          path: ci-artifacts/benchmarks
          if_no_artifact_found: warn

      - name: Download CI coverage (if available)
        if: github.event_name == 'workflow_run' && matrix.os == 'linux-self-hosted'
        uses: dawidd6/action-download-artifact@v11
        continue-on-error: true
        with:
          workflow: ci.yml
          workflow_conclusion: success
          name: coverage-report
          path: ci-artifacts/coverage
          if_no_artifact_found: warn

      - name: Cache Conan packages
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: ~/.conan2/p
          key: conan-release-${{ runner.os }}-${{ matrix.suffix }}-${{ hashFiles('conan.lock', 'conanfile.py', 'CMakePresets.json') }}
          restore-keys: |
            conan-release-${{ runner.os }}-${{ matrix.suffix }}-
            conan-${{ runner.os }}-

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      - name: Install Conan
        shell: bash
        run: |
          pip3 install conan || python3 -m pip install conan || python -m pip install conan
          conan --version

          # Configure Conan for robustness
          mkdir -p ~/.conan2
          cp .conan/global.conf ~/.conan2/global.conf

      - name: Setup Conan Profile
        if: matrix.os == 'macos-hosted-x64'
        shell: bash
        run: |
          # Hosted-only: do not modify Conan profiles on self-hosted runners
          conan profile detect --force

          # Force correct architecture for ARM64 macOS
          if [[ "${{ matrix.suffix }}" == "macos-arm64" ]]; then
            sed -i '' 's/arch=x86_64/arch=armv8/' ~/.conan2/profiles/default || true
            sed -i '' 's/arch=X86_64/arch=armv8/' ~/.conan2/profiles/default || true
          fi

          # Ensure C++20 support
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          else
            sed -i 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          fi
          # Show profile for debugging (to stderr to avoid contaminating outputs)
          echo "Conan profile configured:" >&2
          conan profile show >&2

      - name: Clean corrupted Conan cache if needed
        shell: bash
        run: |
          # Function to remove corrupted package
          clean_corrupted_package() {
            local package="$1"
            echo "Cleaning corrupted package: $package"
            # Try to remove the specific package
            conan remove "$package" -c 2>/dev/null || true
            # Also try to clean the download cache
            find ~/.conan2/p -name "*${package%%/*}*" -type f -name "*.tgz" -delete 2>/dev/null || true
          }

          # Test if cache has issues by trying to list packages
          if ! conan list "*" 2>/dev/null; then
            echo "Conan cache appears corrupted, cleaning locks and temp files..."
            conan cache clean --locks --temp 2>/dev/null || true
            echo "Conan cache locks/temp cleaned"
          fi

          # Known problematic packages that often get corrupted
          for pkg in "gtest/1.14.0" "boost/1.83.0"; do
            if [ -d ~/.conan2/p ] && find ~/.conan2/p -name "*${pkg%%/*}*" -name "*.tgz" 2>/dev/null | grep -q .; then
              # Check if the tgz files are valid
              for tgz in $(find ~/.conan2/p -name "*${pkg%%/*}*" -name "*.tgz" 2>/dev/null); do
                if ! tar -tzf "$tgz" >/dev/null 2>&1; then
                  echo "Found corrupted archive: $tgz"
                  rm -f "$tgz"
                  clean_corrupted_package "$pkg"
                fi
              done
            fi
          done

      - name: Configure with Conan
        shell: bash
        run: |
          # Simple native build for all platforms
          echo "Native build for ${{ matrix.suffix }}"

          # Install dependencies with Conan
          conan install . \
            --output-folder=build/conan-release \
            -s build_type=Release \
            --build=missing \
            -o "boost/*:without_locale=True" \
            -o "boost/*:without_stacktrace=True"

          # Configure with CMake using Conan presets
          cmake --preset conan-release \
            -DYAMS_BUILD_PROFILE=release \
            -DYAMS_BUILD_DOCS=OFF \
            -DYAMS_BUILD_TESTS=OFF \
            -DYAMS_BUILD_BENCHMARKS=OFF \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            -DCMAKE_INSTALL_PREFIX="$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}" \
            ${{ matrix.cmake_args }}

          # Update BUILD_DIR to point to Conan build directory
          echo "BUILD_DIR=build/conan-release/build/Release" >> $GITHUB_ENV

      - name: Build
        shell: bash
        run: |
          cmake --build --preset conan-release --parallel

      - name: Collect benchmark results from CI
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"

          # Check if we have CI benchmark artifacts
          if [ -d "ci-artifacts/benchmarks" ] && [ "$(ls -A ci-artifacts/benchmarks/*.json 2>/dev/null)" ]; then
            echo "Using benchmark results from CI workflow"
            cp ci-artifacts/benchmarks/*.json "$BUILD_DIR/bench_results/" || true
            echo "Found $(ls -1 $BUILD_DIR/bench_results/*.json | wc -l) benchmark files from CI"
          else
            echo "No CI benchmark results available (release builds don't include benchmarks)"
            touch "$BUILD_DIR/bench_results/.empty"
          fi

      - name: Install
        shell: bash
        run: |
          # Ensure BUILD_DIR is properly set
          if [ ! -d "$BUILD_DIR" ]; then
            echo "BUILD_DIR not found at $BUILD_DIR, checking for alternative..."
            if [ -d "build/conan-release/build/Release" ]; then
              BUILD_DIR="build/conan-release/build/Release"
              echo "Using BUILD_DIR: $BUILD_DIR"
              echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
            fi
          fi
          cmake --install "$BUILD_DIR" --config Release

      - name: Generate release summary
        shell: bash
        run: |
          SUMMARY_FILE="$BUILD_DIR/release_summary.md"
          echo "## Release Build Information (v${{ steps.v.outputs.version }})" > "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          echo "**Platform:** ${{ matrix.suffix }}" >> "$SUMMARY_FILE"
          echo "**Build Type:** Release" >> "$SUMMARY_FILE"

          # Only mention CI validation if we actually have CI artifacts
          if [ -d "ci-artifacts" ] && [ "$(ls -A ci-artifacts/ 2>/dev/null)" ]; then
            echo "**CI Status:** Tests and benchmarks from CI workflow" >> "$SUMMARY_FILE"
          fi
          echo "" >> "$SUMMARY_FILE"

          # Add coverage information if available
          if [ -f "ci-artifacts/coverage/coverage.xml" ]; then
            echo "### Test Coverage" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            # Try to extract coverage percentage from XML
            coverage_pct=$(python3 -c "
            import xml.etree.ElementTree as ET
            try:
              tree = ET.parse('ci-artifacts/coverage/coverage.xml')
              root = tree.getroot()
              line_rate = float(root.get('line-rate', 0))
              print(f'{line_rate * 100:.1f}%')
              except:
                print('N/A')
                " 2>/dev/null || echo 'N/A')
                echo "**Line Coverage:** $coverage_pct" >> "$SUMMARY_FILE"
                echo "" >> "$SUMMARY_FILE"
                fi

          # Add benchmark results if available from CI
          if [ -d "$BUILD_DIR/bench_results" ] && [ "$(find $BUILD_DIR/bench_results -name '*.json' 2>/dev/null)" ]; then
            echo "### Performance Metrics" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "| Benchmark | Time (ns/op) | CPU (ns/op) | Memory |" >> "$SUMMARY_FILE"
            echo "|-----------|--------------|-------------|--------|" >> "$SUMMARY_FILE"

            # Parse JSON benchmark files and extract key metrics
            for json_file in "$BUILD_DIR/bench_results"/*.json; do
              if [ -f "$json_file" ]; then
                python3 -c "
                import json, sys
                try:
                  with open('$json_file') as f:
                    data = json.load(f)
                    if 'benchmarks' in data:
                      for bench in data['benchmarks']:
                        name = bench.get('name', 'Unknown')
                        real_time = bench.get('real_time', 0)
                        cpu_time = bench.get('cpu_time', 0)
                        bytes_per_sec = bench.get('bytes_per_second', 0)
                        items_per_sec = bench.get('items_per_second', 0)
                        memory = f'{bytes_per_sec/1024/1024:.1f} MB/s' if bytes_per_sec > 0 else f'{items_per_sec:.0f} ops/s' if items_per_sec > 0 else 'N/A'
                        print(f'| {name} | {real_time:.0f} | {cpu_time:.0f} | {memory} |')
                except: pass
                " >> "$SUMMARY_FILE" 2>/dev/null || true
              fi
            done
            echo "" >> "$SUMMARY_FILE"
          fi

          echo "Generated release summary at: $SUMMARY_FILE"
          cat "$SUMMARY_FILE"

      - name: Package
        id: pkg
        shell: bash
        run: |
          cd "$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}"
          VERSION="${{ steps.v.outputs.version }}"
          SUFFIX="${{ matrix.suffix }}"
          OUTDIR="$GITHUB_WORKSPACE"
          if [ "${{ matrix.packaging }}" = "zip" ]; then
            ASSET="yams-${VERSION}-${SUFFIX}.zip"
            zip -r "$OUTDIR/$ASSET" .
          else
            ASSET="yams-${VERSION}-${SUFFIX}.tar.gz"
            tar czf "$OUTDIR/$ASSET" .
          fi
          echo "asset_path=$OUTDIR/$ASSET" >> "$GITHUB_OUTPUT"
          echo "Created asset: $OUTDIR/$ASSET"

      - name: Combine release notes with build information
        shell: bash
        run: |
          COMBINED_NOTES="$BUILD_DIR/combined_release_notes.md"
          echo "${{ steps.changelog.outputs.release_notes }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add release summary if it exists
          if [ -f "$BUILD_DIR/release_summary.md" ]; then
            cat "$BUILD_DIR/release_summary.md" >> "$COMBINED_NOTES"
          fi

          echo "Combined release notes:"
          cat "$COMBINED_NOTES"

      - name: Create GitHub Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          body_path: ${{ env.BUILD_DIR }}/combined_release_notes.md
          files: |
            ${{ steps.pkg.outputs.asset_path }}
            ${{ env.BUILD_DIR }}/bench_results/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
