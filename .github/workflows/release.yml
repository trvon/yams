name: Release

on:
  push:
    tags:
      - "v*"
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: write

jobs:
  build-release:
    name: Build and Release (${{ matrix.os }})
    # Only run release if CI passed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-self-hosted
            runs_on: '["self-hosted", "Linux", "X64"]'
            packaging: tgz
            cmake_args: ""
            suffix: linux-x86_64
          - os: macos-self-hosted-x64
            runs_on: '["self-hosted", "macOS", "X64"]'
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="x86_64"
            suffix: macos-x86_64
          - os: macos-self-hosted-arm64
            runs_on: '["self-hosted", "macOS", "ARM64"]'
            packaging: zip
            cmake_args: -DCMAKE_OSX_ARCHITECTURES="arm64"
            suffix: macos-arm64
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    env:
      BUILD_DIR: build
      STAGE_DIR: stage
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Ensure tags are available for git describe and version derivation
          fetch-depth: 0

      - name: Extract version from tag
        id: v
        shell: bash
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Detected version: $VERSION"

      - name: Extract release notes from CHANGELOG.md
        id: changelog
        uses: ffurrer2/extract-release-notes@v2
        with:
          changelog_file: CHANGELOG.md

      - name: Configure (CMake)
        shell: bash
        run: |
          cmake -S . -B "$BUILD_DIR" \
            -DCMAKE_BUILD_TYPE=Release \
            -DYAMS_BUILD_PROFILE=release \
            -DYAMS_BUILD_DOCS=OFF \
            -DYAMS_VERSION="${{ steps.v.outputs.version }}" \
            -DCMAKE_INSTALL_PREFIX="$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}" \
            ${{ matrix.cmake_args }}

      - name: Build
        shell: bash
        run: |
          cmake --build "$BUILD_DIR" --config Release --parallel

      - name: Run quick benchmarks for release metrics
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"
          # Find all benchmark executables (named *_bench, *_bench.exe, or *_benchmark*)
          benches=()
          while IFS= read -r exe; do
            [ -n "$exe" ] && benches+=("$exe")
          done < <(find "$BUILD_DIR" -type f \( -name "*_bench" -o -name "*_bench.exe" -o -name "*_benchmark*" \) 2>/dev/null | sort)

          if [ ${#benches[@]} -eq 0 ]; then
            echo "No benchmark executables found (expected - release builds don't include benchmarks)."
            # Create empty results directory
            touch "$BUILD_DIR/bench_results/.empty"
          else
            echo "Found benchmarks in release build (unexpected but running them):"
            for exe in "${benches[@]}"; do
              name=$(basename "$exe")
              out="$BUILD_DIR/bench_results/${name%.exe}.json"
              echo "Running $exe -> $out"
              "$exe" --benchmark_min_time=0.05 --benchmark_format=json --benchmark_out="$out" || true
            done
          fi

      - name: Install
        shell: bash
        run: |
          cmake --install "$BUILD_DIR" --config Release

      - name: Generate release summary
        shell: bash
        run: |
          SUMMARY_FILE="$BUILD_DIR/release_summary.md"
          echo "## ðŸ“¦ Release Build Information (v${{ steps.v.outputs.version }})" > "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          echo "**Platform:** ${{ matrix.suffix }}" >> "$SUMMARY_FILE"
          echo "**Build Type:** Release (optimized for production)" >> "$SUMMARY_FILE"
          echo "**Validation:** All tests passed in CI pipeline" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"

          # Add benchmark results if available (unlikely in release builds)
          if [ -d "$BUILD_DIR/bench_results" ] && [ "$(find $BUILD_DIR/bench_results -name '*.json' 2>/dev/null)" ]; then
            echo "### âš¡ Performance Metrics" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "| Benchmark | Time (ns/op) | CPU (ns/op) | Memory |" >> "$SUMMARY_FILE"
            echo "|-----------|--------------|-------------|--------|" >> "$SUMMARY_FILE"

            # Parse JSON benchmark files and extract key metrics
            for json_file in "$BUILD_DIR/bench_results"/*.json; do
              if [ -f "$json_file" ]; then
                python3 -c "
                import json, sys
                try:
                  with open('$json_file') as f:
                    data = json.load(f)
                    if 'benchmarks' in data:
                      for bench in data['benchmarks']:
                        name = bench.get('name', 'Unknown')
                        real_time = bench.get('real_time', 0)
                        cpu_time = bench.get('cpu_time', 0)
                        bytes_per_sec = bench.get('bytes_per_second', 0)
                        items_per_sec = bench.get('items_per_second', 0)
                        memory = f'{bytes_per_sec/1024/1024:.1f}MB/s' if bytes_per_sec > 0 else f'   {items_per_sec:.0f} ops/s' if items_per_sec > 0 else 'N/A'
                        print(f'| {name} | {real_time:.0f} | {cpu_time:.0f} | {memory} |')
                except: pass
                " >> "$SUMMARY_FILE" 2>/dev/null || true
              fi
            done
            echo "" >> "$SUMMARY_FILE"
          else
            echo "### âœ… Quality Assurance" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "- **Tests:** Passed in CI (unit, integration, benchmarks)" >> "$SUMMARY_FILE"
            echo "- **Build:** Production-optimized release configuration" >> "$SUMMARY_FILE"
            echo "- **Platform:** Verified for ${{ matrix.suffix }}" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
          fi

          echo "Generated release summary at: $SUMMARY_FILE"
          cat "$SUMMARY_FILE"

      - name: Package
        id: pkg
        shell: bash
        run: |
          cd "$GITHUB_WORKSPACE/${{ env.STAGE_DIR }}"
          VERSION="${{ steps.v.outputs.version }}"
          SUFFIX="${{ matrix.suffix }}"
          OUTDIR="$GITHUB_WORKSPACE"
          if [ "${{ matrix.packaging }}" = "zip" ]; then
            ASSET="yams-${VERSION}-${SUFFIX}.zip"
            zip -r "$OUTDIR/$ASSET" .
          else
            ASSET="yams-${VERSION}-${SUFFIX}.tar.gz"
            tar czf "$OUTDIR/$ASSET" .
          fi
          echo "asset_path=$OUTDIR/$ASSET" >> "$GITHUB_OUTPUT"
          echo "Created asset: $OUTDIR/$ASSET"

      - name: Combine release notes with build information
        shell: bash
        run: |
          COMBINED_NOTES="$BUILD_DIR/combined_release_notes.md"
          echo "${{ steps.changelog.outputs.release_notes }}" > "$COMBINED_NOTES"
          echo "" >> "$COMBINED_NOTES"

          # Add release summary if it exists
          if [ -f "$BUILD_DIR/release_summary.md" ]; then
            cat "$BUILD_DIR/release_summary.md" >> "$COMBINED_NOTES"
          fi

          echo "Combined release notes:"
          cat "$COMBINED_NOTES"

      - name: Create GitHub Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          body_path: ${{ env.BUILD_DIR }}/combined_release_notes.md
          files: |
            ${{ steps.pkg.outputs.asset_path }}
            ${{ env.BUILD_DIR }}/bench_results/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
