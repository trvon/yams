name: CI

on:
  push:
    branches: [main, master]
    paths-ignore:
      - "**/*.md"
      - "docs/**"
  pull_request:
    branches: [main, master]

permissions:
  contents: read

jobs:
  build-test-package:
    name: Build, Test, and Package (${{ matrix.os }}, ${{ matrix.build_type }})
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: linux-self-hosted
            platform: linux
            runs_on: '["self-hosted","Linux","X64"]'
            build_type: conan
          - os: macos-self-hosted
            platform: macos
            runs_on: '["self-hosted", "macOS", "X64"]'
            build_type: conan

    env:
      BUILD_DIR: build
      INSTALL_PREFIX: prefix

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Conan packages
        uses: actions/cache@v4
        with:
          path: ~/.conan2/p
          key: conan-${{ runner.os }}-${{ matrix.platform }}-${{ hashFiles('conan.lock', 'conanfile.py', 'CMakePresets.json') }}
          restore-keys: |
            conan-${{ runner.os }}-${{ matrix.platform }}-

      - name: Ensure Conan is installed
        shell: bash
        run: |
          if ! command -v conan &> /dev/null; then
            echo "Conan not found, installing..."
            pip3 install conan || python3 -m pip install conan || python -m pip install conan
          fi
          conan --version
          
          # Ensure profile exists
          if [ ! -f ~/.conan2/profiles/default ]; then
            conan profile detect --force
          fi

      - name: Configure with Conan (with tests enabled)
        shell: bash
        run: |
          # Create/refresh Release lockfile with tests enabled
          conan lock create . -s build_type=Release --options "yams/*:build_tests=True" --lockfile-out=conan.lock --build=missing

          # Install dependencies to preset build folder using the lockfile
          # Disable problematic Boost components for cross-compilation compatibility
          conan install . \
            --output-folder=build/conan-release \
            -s build_type=Release \
            --options "yams/*:build_tests=True" \
            --lockfile=conan.lock \
            --build=missing \
            -o "boost/*:without_locale=True" \
            -o "boost/*:without_stacktrace=True"

          # Configure with CMake using Conan presets (tests will be built)
          # Enable coverage for Linux builds
          if [ "${{ matrix.platform }}" = "linux" ]; then
            cmake --preset conan-release -DYAMS_BUILD_DOCS=OFF -DYAMS_BUILD_TESTS=ON -DYAMS_ENABLE_COVERAGE=ON
          else
            cmake --preset conan-release -DYAMS_BUILD_DOCS=OFF -DYAMS_BUILD_TESTS=ON
          fi
          echo "BUILD_DIR=build/conan-release/build/Release" >> $GITHUB_ENV

      - name: Build with Conan
        shell: bash
        run: |
          cmake --build --preset conan-release

      - name: Build test executables
        shell: bash
        run: |
          echo "Building test executables..."
          cd "$BUILD_DIR"
          
          # Build individual test targets
          TEST_TARGETS="chunking_tests compression_tests crypto_tests detection_tests 
                       extraction_tests indexing_tests integrity_unit_tests metadata_tests 
                       search_tests reference_counter_unit_tests vector_database_tests 
                       wal_manager_unit_tests test_content_api test_tui_services"
          
          for target in $TEST_TARGETS; do
            echo "Building $target..."
            if cmake --build . --target $target 2>/dev/null; then
              echo "✅ $target built successfully"
            else
              echo "⚠️ $target failed to build (may not exist or have compilation errors)"
            fi
          done
          
          cd -

      - name: Verify test executables
        shell: bash
        run: |
          echo "Checking for test executables in $BUILD_DIR..."
          test_count=$(find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l || echo "0")
          echo "Found $test_count test executables"
          if [ "$test_count" -eq 0 ]; then
            echo "WARNING: No test executables found!"
            echo "Checking CMakeCache for YAMS_BUILD_TESTS..."
            grep -i "YAMS_BUILD_TESTS" "$BUILD_DIR/CMakeCache.txt" 2>/dev/null || echo "CMakeCache.txt not found"
            echo "Listing directories that might contain tests:"
            find "$BUILD_DIR" -type d -name "*test*" 2>/dev/null | head -10 || echo "No test directories found"
          else
            echo "Test executables found:"
            find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | head -10
          fi
          
          # Check for test compilation failures
          if [ -f "$BUILD_DIR/CTestTestfile.cmake" ] && grep -q "_NOT_BUILT" "$BUILD_DIR/CTestTestfile.cmake" 2>/dev/null; then
            echo "WARNING: Some tests failed to build!"
            echo "Failed test targets:"
            grep "_NOT_BUILT" "$BUILD_DIR/CTestTestfile.cmake" | head -10
            # Don't exit with error - we'll handle this in test run step
          fi

      - name: Run tests
        shell: bash
        run: |
          if [ -f "$BUILD_DIR/CTestTestfile.cmake" ]; then
            echo "Running tests with ctest..."
            # Set ASAN options to be less strict for CI
            export ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0
            # Run ctest but don't fail the build if some tests fail
            ctest --preset conan-release --output-on-failure || true
            
            # Also run tests individually for better error reporting
            echo ""
            echo "Running individual test executables for detailed results..."
            cd "$BUILD_DIR"
            PASSED=0
            FAILED=0
            for test_exe in $(find . -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null); do
              echo ""
              echo "=== Running $(basename $test_exe) ==="
              if ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0 $test_exe --gtest_brief=1 2>&1; then
                echo "✅ $(basename $test_exe) passed"
                PASSED=$((PASSED + 1))
              else
                echo "❌ $(basename $test_exe) failed"
                FAILED=$((FAILED + 1))
              fi
            done
            cd -
            
            echo ""
            echo "Test Summary: $PASSED passed, $FAILED failed"
            # For now, don't fail the build on test failures
            # exit $FAILED
            ctest --preset conan-release --output-on-failure
          else
            echo "No CTest configuration found. Checking for test executables..."
            test_count=$(find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l)
            echo "Found $test_count test executables"
            if [ "$test_count" -eq 0 ]; then
              echo "WARNING: No test executables found!"
              echo "Checking CMakeCache for YAMS_BUILD_TESTS..."
              grep -i "YAMS_BUILD_TESTS" "$BUILD_DIR/CMakeCache.txt" 2>/dev/null || echo "CMakeCache.txt not found"
            fi
          fi

      - name: Run benchmarks
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"
          # Find all benchmark executables (named *_bench, *_bench.exe, or *_benchmark*)
          benches=()
          while IFS= read -r exe; do
            [ -n "$exe" ] && benches+=("$exe")
          done < <(find "$BUILD_DIR" -type f \( -name "*_bench" -o -name "*_bench.exe" -o -name "*_benchmark*" \) -executable 2>/dev/null | sort)
          
          if [ ${#benches[@]} -eq 0 ]; then
            echo "No benchmark executables found."
          else
            for exe in "${benches[@]}"; do
              name=$(basename "$exe")
              out="$BUILD_DIR/bench_results/${name%.exe}.json"
              echo "Running $exe -> $out"
              "$exe" --benchmark_min_time=0.1 --benchmark_format=json --benchmark_out="$out" || true
            done
          fi

      - name: Generate coverage report (Linux)
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          # Install gcovr for coverage reporting
          pip install gcovr || true

          # Generate coverage reports if gcovr is available
          if command -v gcovr &> /dev/null; then
            echo "Generating coverage reports..."
            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' \
              --html --html-details \
              --output "$BUILD_DIR/coverage.html" || echo "Coverage HTML generation failed"

            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' \
              --xml \
              --output "$BUILD_DIR/coverage.xml" || echo "Coverage XML generation failed"

            # Display summary
            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' || echo "Coverage summary failed"
          else
            echo "gcovr not available, skipping coverage reports"
          fi

      - name: Install
        shell: bash
        run: |
          # Make install prefix absolute path to avoid confusion
          ABSOLUTE_PREFIX="$GITHUB_WORKSPACE/${{ env.INSTALL_PREFIX }}"
          echo "Installing to: $ABSOLUTE_PREFIX"
          
          # Debug: Check CMake install variables
          echo "Debug: Checking CMake cache for install paths..."
          grep -E "CMAKE_INSTALL|SPDLOG" "$BUILD_DIR/CMakeCache.txt" | head -20 || true
          
          cmake --install "$BUILD_DIR" --config Release --prefix "$ABSOLUTE_PREFIX"
          
          # Verify installation succeeded
          if [ ! -d "$ABSOLUTE_PREFIX" ]; then
            echo "ERROR: Install prefix directory does not exist at: $ABSOLUTE_PREFIX"
            echo "Current working directory: $(pwd)"
            echo "BUILD_DIR contents:"
            ls -la "$BUILD_DIR" || true
            echo "GITHUB_WORKSPACE contents:"
            ls -la "$GITHUB_WORKSPACE" || true
            exit 1
          fi
          echo "Installation contents at $ABSOLUTE_PREFIX:"
          ls -la "$ABSOLUTE_PREFIX" || true
          
          # Update environment variable for subsequent steps
          echo "INSTALL_PREFIX=$ABSOLUTE_PREFIX" >> $GITHUB_ENV

      - name: Verify macOS packaging (PDFium @rpath and rpath)
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail

          # Locate the installed CLI binary
          BIN=""
          if [ -x "$INSTALL_PREFIX/bin/yams" ]; then
            BIN="$INSTALL_PREFIX/bin/yams"
          elif [ -x "$GITHUB_WORKSPACE/${{ env.BUILD_DIR }}/tools/yams-cli/yams" ]; then
            BIN="$GITHUB_WORKSPACE/${{ env.BUILD_DIR }}/tools/yams-cli/yams"
          elif [ -x "build/Release/tools/yams-cli/yams" ]; then
            BIN="build/Release/tools/yams-cli/yams"
          else
            echo "ERROR: yams binary not found in expected locations"
            echo "INSTALL_PREFIX contents:"
            ls -R "$INSTALL_PREFIX" || true
            exit 1
          fi

          echo "Using yams binary: $BIN"
          echo "otool -L output:"
          otool -L "$BIN"

          # Check if PDFium is linked - only verify if it's actually linked
          if otool -L "$BIN" | grep -q 'libpdfium'; then
            echo "PDFium detected in binary, verifying @rpath configuration..."
            # Assert that the binary references @rpath/libpdfium.dylib (not absolute path)
            if ! otool -L "$BIN" | grep -q '@rpath/libpdfium.dylib'; then
              echo "ERROR: PDFium is linked but not using @rpath/libpdfium.dylib"
              echo "Found PDFium references:"
              otool -L "$BIN" | grep libpdfium || true
              exit 1
            fi
            echo "✅ PDFium correctly linked with @rpath/libpdfium.dylib"
            
            # Also verify LC_RPATH contains @loader_path/../lib when PDFium is linked
            if ! otool -l "$BIN" | awk '/LC_RPATH/{flag=1} flag&&/path/{print $2} /LC_/&&$0!~/LC_RPATH/{flag=0}' | grep -q '@loader_path/../lib'; then
              echo "ERROR: @loader_path/../lib not present in LC_RPATH of yams binary (required for PDFium)"
              exit 1
            fi
            echo "✅ LC_RPATH correctly configured for PDFium"

            # Verify libpdfium.dylib has install_name set to @rpath/libpdfium.dylib
            PDF="$INSTALL_PREFIX/lib/libpdfium.dylib"
            if [ -f "$PDF" ]; then
              echo "otool -D for libpdfium.dylib:"
              otool -D "$PDF" || true
              if ! otool -D "$PDF" | grep -q '@rpath/libpdfium.dylib'; then
                echo "ERROR: libpdfium.dylib install_name is not @rpath/libpdfium.dylib"
                exit 1
              fi
              echo "✅ libpdfium.dylib install_name correctly set"
            else
              echo "libpdfium.dylib not found at $PDF, attempting discovery..."
              PDF_ALT=$(find "$INSTALL_PREFIX" -maxdepth 2 -name 'libpdfium.dylib' -print -quit || true)
              if [ -n "$PDF_ALT" ]; then
                echo "Found libpdfium.dylib at: $PDF_ALT"
                if ! otool -D "$PDF_ALT" | grep -q '@rpath/libpdfium.dylib'; then
                  echo "ERROR: libpdfium.dylib install_name is not @rpath/libpdfium.dylib (found at $PDF_ALT)"
                  exit 1
                fi
                echo "✅ libpdfium.dylib install_name correctly set"
              else
                echo "WARNING: libpdfium.dylib not present in install prefix; skipping install_name verification"
              fi
            fi
          else
            echo "ℹ️  PDFium not linked in this build (this is acceptable)"
          fi

      - name: Upload installed prefix
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-install-${{ matrix.os }}
          path: ${{ env.INSTALL_PREFIX }}
          if-no-files-found: error

      - name: Package (CPack)
        shell: bash
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          # Generate default TGZ/ZIP packages if configured
          cpack -G TGZ || true
          cpack -G ZIP || true
          # List generated packages (if any)
          ls -la || true

      - name: Upload packages
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-packages-${{ matrix.os }}
          path: |
            ${{ env.BUILD_DIR }}/*.tar.gz
            ${{ env.BUILD_DIR }}/*.tgz
            ${{ env.BUILD_DIR }}/*.zip
            build/Release/*.tar.gz
            build/Release/*.tgz
            build/Release/*.zip
          if-no-files-found: ignore

      - name: Upload benchmark results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-${{ matrix.os }}
          path: ${{ env.BUILD_DIR }}/bench_results
          if-no-files-found: ignore

      - name: Run retrieval evaluation (fixture)
        shell: bash
        run: |
          set -euo pipefail

          # Locate evaluator binary
          if [ -x "build/Release/tools/eval/yams-eval" ]; then
            EVAL_BIN="build/Release/tools/eval/yams-eval"
          elif [ -x "$BUILD_DIR/tools/eval/yams-eval" ]; then
            EVAL_BIN="$BUILD_DIR/tools/eval/yams-eval"
          elif [ -x "$INSTALL_PREFIX/bin/yams-eval" ]; then
            EVAL_BIN="$INSTALL_PREFIX/bin/yams-eval"
          else
            echo "yams-eval not found; skipping retrieval evaluation."
            exit 0
          fi

          # Locate CLI binary
          if [ -x "build/Release/tools/yams-cli/yams" ]; then
            CLI_BIN="build/Release/tools/yams-cli/yams"
          elif [ -x "$BUILD_DIR/tools/yams-cli/yams" ]; then
            CLI_BIN="$BUILD_DIR/tools/yams-cli/yams"
          elif [ -x "$INSTALL_PREFIX/bin/yams" ]; then
            CLI_BIN="$INSTALL_PREFIX/bin/yams"
          else
            echo "yams CLI not found; skipping retrieval evaluation."
            exit 0
          fi

          # Queries fixture
          QUERIES="yams/paper/data/queries.jsonl"
          if [ ! -f "$QUERIES" ]; then
            echo "Queries fixture not found at $QUERIES; skipping."
            exit 0
          fi

          # Output dir
          OUT_DIR="$BUILD_DIR/eval_results"
          mkdir -p "$OUT_DIR"

          # Run hybrid evaluation
          "$EVAL_BIN" --queries "$QUERIES" --cli "$CLI_BIN" --limit 20 --k 5,10,20 --mode hybrid --output "$OUT_DIR/retrieval_metrics.hybrid.json" || true

          # Run fail-open KG evaluation
          "$EVAL_BIN" --queries "$QUERIES" --cli "$CLI_BIN" --limit 20 --k 5,10,20 --mode fail-open-kg --output "$OUT_DIR/retrieval_metrics.failopen.json" || true

      - name: Upload retrieval metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: retrieval-metrics-${{ matrix.os }}
          path: ${{ env.BUILD_DIR }}/eval_results
          if-no-files-found: ignore

      - name: Upload coverage report
        if: matrix.platform == 'linux' && always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            ${{ env.BUILD_DIR }}/coverage.html
            ${{ env.BUILD_DIR }}/coverage.xml
          if-no-files-found: ignore

      - name: Upload CLI binary (if present)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-cli-${{ matrix.os }}
          path: |
            ${{ env.BUILD_DIR }}/tools/yams-cli/yams
            ${{ env.BUILD_DIR }}/tools/yams-cli/Debug/yams
            ${{ env.BUILD_DIR }}/tools/yams-cli/Release/yams
            build/Release/tools/yams-cli/yams
          if-no-files-found: ignore
