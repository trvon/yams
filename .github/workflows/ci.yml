name: CI

on:
  push:
    branches: [main, master]
    paths-ignore:
      - "**/*.md"
      - "docs/**"
  pull_request:
    branches: [main, master]

permissions:
  contents: read

jobs:
  build-test-package:
    name: Build, Test, and Package (${{ matrix.os }}, ${{ matrix.build_type }})
    runs-on: ${{ fromJSON(matrix.runs_on) }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: linux-self-hosted
            platform: linux
            runs_on: '["self-hosted","Linux","X64"]'
            build_type: conan
          - os: macos-self-hosted
            platform: macos
            runs_on: '["self-hosted", "macOS", "X64"]'
            build_type: conan
          - os: macos-github-x64
            platform: macos-x64
            runs_on: '"macos-13"' # GitHub hosted Intel runner
            build_type: conan

    env:
      BUILD_DIR: build
      INSTALL_PREFIX: prefix

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Conan packages
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: ~/.conan2/p
          key: conan-${{ runner.os }}-${{ matrix.platform }}-${{ hashFiles('conan.lock', 'conanfile.py', 'CMakePresets.json') }}
          restore-keys: |
            conan-${{ runner.os }}-${{ matrix.platform }}-

      - name: Ensure Conan is installed
        shell: bash
        run: |
          if ! command -v conan &> /dev/null; then
            echo "Conan not found, installing..."
            pip3 install conan || python3 -m pip install conan || python -m pip install conan
          fi
          conan --version

          # Configure Conan for robustness
          mkdir -p ~/.conan2
          cp .conan/global.conf ~/.conan2/global.conf

          # Ensure profile exists
          if [ ! -f ~/.conan2/profiles/default ]; then
            conan profile detect --force
          fi

          # Ensure C++20 is set in the profile
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          else
            sed -i 's/compiler.cppstd=.*/compiler.cppstd=20/' ~/.conan2/profiles/default || true
          fi

      - name: Clean corrupted Conan cache if needed
        shell: bash
        run: |
          # Function to remove corrupted package
          clean_corrupted_package() {
            local package="$1"
            echo "Cleaning corrupted package: $package"
            # Try to remove the specific package
            conan remove "$package" -c 2>/dev/null || true
            # Also try to clean the download cache
            find ~/.conan2/p -name "*${package%%/*}*" -type f -name "*.tgz" -delete 2>/dev/null || true
          }

          # Test if cache has issues by trying to list packages
          if ! conan list "*" 2>/dev/null; then
            echo "Conan cache appears corrupted, cleaning locks and temp files..."
            conan cache clean --locks --temp 2>/dev/null || true
            echo "Conan cache locks/temp cleaned"
          fi

          # Known problematic packages that often get corrupted
          for pkg in "gtest/1.14.0" "boost/1.83.0"; do
            # More aggressive cleaning for problematic packages
            if [ -d ~/.conan2/p ]; then
              # Remove any gtest directories if they exist
              if [[ "$pkg" == "gtest/1.14.0" ]]; then
                echo "Cleaning gtest package directories..."
                rm -rf ~/.conan2/p/gtest* 2>/dev/null || true
                rm -rf ~/.conan2/p/b/gtest* 2>/dev/null || true
              fi

              # Check for corrupted archives
              if find ~/.conan2/p -name "*${pkg%%/*}*" -name "*.tgz" 2>/dev/null | grep -q .; then
                for tgz in $(find ~/.conan2/p -name "*${pkg%%/*}*" -name "*.tgz" 2>/dev/null); do
                  if ! tar -tzf "$tgz" >/dev/null 2>&1; then
                    echo "Found corrupted archive: $tgz"
                    rm -f "$tgz"
                    clean_corrupted_package "$pkg"
                  fi
                done
              fi
            fi
          done

      - name: Configure with Conan (with tests enabled)
        shell: bash
        run: |
          # Detect actual machine architecture
          NATIVE_ARCH=$(uname -m)
          echo "Native architecture: $NATIVE_ARCH"
          echo "Platform: ${{ matrix.platform }}"

          # For macOS, always do native builds since runner can be dual-labeled
          # The runner might have both X64 and ARM64 labels but is actually ARM64
          if [[ "${{ matrix.platform }}" == "macos" ]] && [[ "$NATIVE_ARCH" == "arm64" ]]; then
            echo "Native ARM64 build on macOS"
            CROSS_COMPILE=false
            HOST_PROFILE="default"
            BUILD_PROFILE="default"
          elif [[ "${{ matrix.platform }}" == "macos" ]] && [[ "$NATIVE_ARCH" == "x86_64" ]]; then
            echo "Native x86_64 build on macOS"
            CROSS_COMPILE=false
            HOST_PROFILE="default"
            BUILD_PROFILE="default"
          else
            # Linux builds are always native
            echo "Native build detected: $NATIVE_ARCH"
            CROSS_COMPILE=false
            HOST_PROFILE="default"
            BUILD_PROFILE="default"
          fi

          # Create/refresh Release lockfile with tests enabled
          if [ "$CROSS_COMPILE" = true ]; then
            conan lock create . -pr:b="$BUILD_PROFILE" -pr:h="$HOST_PROFILE" -s build_type=Release --options "yams/*:build_tests=True" --lockfile-out=conan.lock --build=missing
          else
            conan lock create . -s build_type=Release --options "yams/*:build_tests=True" --lockfile-out=conan.lock --build=missing
          fi

          # Install dependencies to preset build folder using the lockfile
          # Disable problematic Boost components for cross-compilation compatibility
          if [ "$CROSS_COMPILE" = true ]; then
            conan install . \
              --output-folder=build/conan-release \
              -pr:b="$BUILD_PROFILE" \
              -pr:h="$HOST_PROFILE" \
              -s build_type=Release \
              --options "yams/*:build_tests=True" \
              --lockfile=conan.lock \
              --build=missing \
              -o "boost/*:without_locale=True" \
              -o "boost/*:without_stacktrace=True" \
              -o "zstd/*:build_programs=False"  # Avoid zstd program build issues
          else
            conan install . \
              --output-folder=build/conan-release \
              -s build_type=Release \
              --options "yams/*:build_tests=True" \
              --lockfile=conan.lock \
              --build=missing \
              -o "boost/*:without_locale=True" \
              -o "boost/*:without_stacktrace=True"
          fi

          # Configure with CMake using Conan presets (tests will be built)
          # Enable coverage for Linux builds
          if [ "${{ matrix.platform }}" = "linux" ]; then
            if ! cmake --preset conan-release -DYAMS_BUILD_DOCS=OFF -DYAMS_BUILD_TESTS=ON -DYAMS_ENABLE_COVERAGE=ON; then
              echo "CMake configuration failed! Showing CMakeError.log:"
              find . -name "CMakeError.log" -exec cat {} \; 2>/dev/null || true
              echo "Showing CMakeOutput.log tail:"
              find . -name "CMakeOutput.log" -exec tail -100 {} \; 2>/dev/null || true
              exit 1
            fi
          else
            if ! cmake --preset conan-release -DYAMS_BUILD_DOCS=OFF -DYAMS_BUILD_TESTS=ON; then
              echo "CMake configuration failed! Showing CMakeError.log:"
              find . -name "CMakeError.log" -exec cat {} \; 2>/dev/null || true
              echo "Showing CMakeOutput.log tail:"
              find . -name "CMakeOutput.log" -exec tail -100 {} \; 2>/dev/null || true
              exit 1
            fi
          fi
          echo "BUILD_DIR=build/conan-release/build/Release" >> $GITHUB_ENV

      - name: Configure Debug with Conan (with tests enabled)
        shell: bash
        run: |
          # Create/refresh Debug lockfile with tests enabled
          conan lock create . -s build_type=Debug --options "yams/*:build_tests=True" --lockfile-out=conan-debug.lock --build=missing || true

          # Install dependencies for Debug to preset build folder
          conan install . \
            --output-folder=build/conan-debug \
            -s build_type=Debug \
            --options "yams/*:build_tests=True" \
            --lockfile=conan-debug.lock \
            --build=missing \
            -o "boost/*:without_locale=True" \
            -o "boost/*:without_stacktrace=True" || true

          # Configure Debug with CMake using Conan presets (tests will be built)
          if ! cmake --preset conan-debug -DYAMS_BUILD_DOCS=OFF -DYAMS_BUILD_TESTS=ON; then
            echo "CMake (Debug) configuration failed! Showing CMakeError.log:"
            find . -name "CMakeError.log" -exec cat {} \; 2>/dev/null || true
            echo "Showing CMakeOutput.log tail:"
            find . -name "CMakeOutput.log" -exec tail -100 {} \; 2>/dev/null || true
            exit 1
          fi
          echo "DEBUG_BUILD_DIR=build/conan-debug/build/Debug" >> $GITHUB_ENV

      - name: Build with Conan (Debug)
        shell: bash
        run: |
          cmake --build --preset conan-debug

      - name: Build with Conan
        shell: bash
        run: |
          cmake --build --preset conan-release

      - name: Build test executables (Debug)
        shell: bash
        run: |
          echo "Building test executables (Debug)..."
          cd "$DEBUG_BUILD_DIR"

          # Build individual test targets
          TEST_TARGETS="chunking_tests compression_tests crypto_tests detection_tests
                       extraction_tests indexing_tests integrity_unit_tests metadata_tests
                       search_tests reference_counter_unit_tests vector_database_tests
                       wal_manager_unit_tests test_content_api test_tui_services"

          for target in $TEST_TARGETS; do
            echo "Building $target (Debug)..."
            if cmake --build . --target $target 2>/dev/null; then
              echo "✅ $target built successfully (Debug)"
            else
              echo "⚠️ $target failed to build in Debug (may not exist or have compilation errors)"
            fi
          done

          cd -

      - name: Build test executables
        shell: bash
        run: |
          echo "Building test executables..."
          cd "$BUILD_DIR"

          # Build individual test targets
          TEST_TARGETS="chunking_tests compression_tests crypto_tests detection_tests
                       extraction_tests indexing_tests integrity_unit_tests metadata_tests
                       search_tests reference_counter_unit_tests vector_database_tests
                       wal_manager_unit_tests test_content_api test_tui_services"

          for target in $TEST_TARGETS; do
            echo "Building $target..."
            if cmake --build . --target $target 2>/dev/null; then
              echo "✅ $target built successfully"
            else
              echo "⚠️ $target failed to build (may not exist or have compilation errors)"
            fi
          done

          cd -

      - name: Verify test executables (Debug)
        shell: bash
        run: |
          echo "Checking for test executables in $DEBUG_BUILD_DIR..."
          test_count=$(find "$DEBUG_BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l || echo "0")
          echo "Found $test_count test executables (Debug)"
          if [ "$test_count" -eq 0 ]; then
            echo "WARNING: No Debug test executables found!"
            echo "Checking CMakeCache for YAMS_BUILD_TESTS..."
            grep -i "YAMS_BUILD_TESTS" "$DEBUG_BUILD_DIR/CMakeCache.txt" 2>/dev/null || echo "CMakeCache.txt not found"
            echo "Listing directories that might contain tests:"
            find "$DEBUG_BUILD_DIR" -type d -name "*test*" 2>/dev/null | head -10 || echo "No test directories found"
          else
            echo "Debug test executables found:"
            find "$DEBUG_BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | head -10
          fi

          # Check for test compilation failures
          if [ -f "$DEBUG_BUILD_DIR/CTestTestfile.cmake" ] && grep -q "_NOT_BUILT" "$DEBUG_BUILD_DIR/CTestTestfile.cmake" 2>/dev/null; then
            echo "WARNING: Some Debug tests failed to build!"
            echo "Failed test targets (Debug):"
            grep "_NOT_BUILT" "$DEBUG_BUILD_DIR/CTestTestfile.cmake" | head -10
          fi

      - name: Verify test executables
        shell: bash
        run: |
          echo "Checking for test executables in $BUILD_DIR..."
          test_count=$(find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l || echo "0")
          echo "Found $test_count test executables"
          if [ "$test_count" -eq 0 ]; then
            echo "WARNING: No test executables found!"
            echo "Checking CMakeCache for YAMS_BUILD_TESTS..."
            grep -i "YAMS_BUILD_TESTS" "$BUILD_DIR/CMakeCache.txt" 2>/dev/null || echo "CMakeCache.txt not found"
            echo "Listing directories that might contain tests:"
            find "$BUILD_DIR" -type d -name "*test*" 2>/dev/null | head -10 || echo "No test directories found"
          else
            echo "Test executables found:"
            find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | head -10
          fi

          # Check for test compilation failures
          if [ -f "$BUILD_DIR/CTestTestfile.cmake" ] && grep -q "_NOT_BUILT" "$BUILD_DIR/CTestTestfile.cmake" 2>/dev/null; then
            echo "WARNING: Some tests failed to build!"
            echo "Failed test targets:"
            grep "_NOT_BUILT" "$BUILD_DIR/CTestTestfile.cmake" | head -10
            # Don't exit with error - we'll handle this in test run step
          fi

      - name: Run tests (Debug)
        shell: bash
        run: |
          if [ -f "$DEBUG_BUILD_DIR/CTestTestfile.cmake" ]; then
            echo "Running tests with ctest (Debug)..."
            # Set ASAN options to be less strict for CI
            export ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0
            # Run ctest but don't fail the build if some tests fail
            ctest --preset conan-debug --output-on-failure || true

            # Also run tests individually for better error reporting
            echo ""
            echo "Running individual Debug test executables for detailed results..."
            cd "$DEBUG_BUILD_DIR"
            PASSED=0
            FAILED=0
            for test_exe in $(find . -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null); do
              echo ""
              echo "=== Running $(basename $test_exe) (Debug) ==="
              if ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0 $test_exe --gtest_brief=1 2>&1; then
                echo "✅ $(basename $test_exe) passed (Debug)"
                PASSED=$((PASSED + 1))
              else
                echo "❌ $(basename $test_exe) failed (Debug)"
                FAILED=$((FAILED + 1))
              fi
            done
            cd -

            echo ""
            echo "Debug Test Summary: $PASSED passed, $FAILED failed"
          else
            echo "No CTest configuration found for Debug. Checking for test executables..."
            test_count=$(find "$DEBUG_BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l)
            echo "Found $test_count test executables (Debug)"
          fi

      - name: Run tests
        shell: bash
        run: |
          if [ -f "$BUILD_DIR/CTestTestfile.cmake" ]; then
            echo "Running tests with ctest..."
            # Set ASAN options to be less strict for CI
            export ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0
            # Run ctest but don't fail the build if some tests fail
            ctest --preset conan-release --output-on-failure || true

            # Also run tests individually for better error reporting
            echo ""
            echo "Running individual test executables for detailed results..."
            cd "$BUILD_DIR"
            PASSED=0
            FAILED=0
            for test_exe in $(find . -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null); do
              echo ""
              echo "=== Running $(basename $test_exe) ==="
              if ASAN_OPTIONS=detect_container_overflow=0:detect_stack_use_after_return=0 $test_exe --gtest_brief=1 2>&1; then
                echo "✅ $(basename $test_exe) passed"
                PASSED=$((PASSED + 1))
              else
                echo "❌ $(basename $test_exe) failed"
                FAILED=$((FAILED + 1))
              fi
            done
            cd -

            echo ""
            echo "Test Summary: $PASSED passed, $FAILED failed"
            # For now, don't fail the build on test failures
            # exit $FAILED
            ctest --preset conan-release --output-on-failure
          else
            echo "No CTest configuration found. Checking for test executables..."
            test_count=$(find "$BUILD_DIR" -type f \( -name "*_test" -o -name "*_tests" \) -executable 2>/dev/null | wc -l)
            echo "Found $test_count test executables"
            if [ "$test_count" -eq 0 ]; then
              echo "WARNING: No test executables found!"
              echo "Checking CMakeCache for YAMS_BUILD_TESTS..."
              grep -i "YAMS_BUILD_TESTS" "$BUILD_DIR/CMakeCache.txt" 2>/dev/null || echo "CMakeCache.txt not found"
            fi
          fi

      - name: Run benchmarks
        shell: bash
        run: |
          mkdir -p "$BUILD_DIR/bench_results"
          # Find all benchmark executables (named *_bench, *_bench.exe, or *_benchmark*)
          benches=()
          while IFS= read -r exe; do
            [ -n "$exe" ] && benches+=("$exe")
          done < <(find "$BUILD_DIR" -type f \( -name "*_bench" -o -name "*_bench.exe" -o -name "*_benchmark*" \) -executable 2>/dev/null | sort)

          if [ ${#benches[@]} -eq 0 ]; then
            echo "No benchmark executables found."
          else
            for exe in "${benches[@]}"; do
              name=$(basename "$exe")
              out="$BUILD_DIR/bench_results/${name%.exe}.json"
              echo "Running $exe -> $out"
              "$exe" --benchmark_min_time=0.1 --benchmark_format=json --benchmark_out="$out" || true
            done
          fi

      - name: Generate coverage report (Linux)
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          # Install gcovr for coverage reporting
          pip install gcovr || true

          # Generate coverage reports if gcovr is available
          if command -v gcovr &> /dev/null; then
            echo "Generating coverage reports..."
            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' \
              --html --html-details \
              --output "$BUILD_DIR/coverage.html" || echo "Coverage HTML generation failed"

            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' \
              --xml \
              --output "$BUILD_DIR/coverage.xml" || echo "Coverage XML generation failed"

            # Display summary
            gcovr --root . \
              --exclude '_deps/*' \
              --exclude 'tests/*' \
              --exclude '.*src/.*/benchmarks/.*' \
              --exclude 'tools/*' \
              --exclude 'build/*' || echo "Coverage summary failed"
          else
            echo "gcovr not available, skipping coverage reports"
          fi

      - name: Install
        shell: bash
        run: |
          # Make install prefix absolute path to avoid confusion
          ABSOLUTE_PREFIX="$GITHUB_WORKSPACE/${{ env.INSTALL_PREFIX }}"
          echo "Installing to: $ABSOLUTE_PREFIX"

          # Debug: Check CMake install variables
          echo "Debug: Checking CMake cache for install paths..."
          grep -E "CMAKE_INSTALL|SPDLOG" "$BUILD_DIR/CMakeCache.txt" | head -20 || true

          cmake --install "$BUILD_DIR" --config Release --prefix "$ABSOLUTE_PREFIX"

          # Verify installation succeeded
          if [ ! -d "$ABSOLUTE_PREFIX" ]; then
            echo "ERROR: Install prefix directory does not exist at: $ABSOLUTE_PREFIX"
            echo "Current working directory: $(pwd)"
            echo "BUILD_DIR contents:"
            ls -la "$BUILD_DIR" || true
            echo "GITHUB_WORKSPACE contents:"
            ls -la "$GITHUB_WORKSPACE" || true
            exit 1
          fi
          echo "Installation contents at $ABSOLUTE_PREFIX:"
          ls -la "$ABSOLUTE_PREFIX" || true

          # Update environment variable for subsequent steps
          echo "INSTALL_PREFIX=$ABSOLUTE_PREFIX" >> $GITHUB_ENV

      - name: Verify macOS packaging (PDFium @rpath and rpath)
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail

          # Locate the installed CLI binary
          BIN=""
          if [ -x "$INSTALL_PREFIX/bin/yams" ]; then
            BIN="$INSTALL_PREFIX/bin/yams"
          elif [ -x "$GITHUB_WORKSPACE/${{ env.BUILD_DIR }}/tools/yams-cli/yams" ]; then
            BIN="$GITHUB_WORKSPACE/${{ env.BUILD_DIR }}/tools/yams-cli/yams"
          elif [ -x "build/Release/tools/yams-cli/yams" ]; then
            BIN="build/Release/tools/yams-cli/yams"
          else
            echo "ERROR: yams binary not found in expected locations"
            echo "INSTALL_PREFIX contents:"
            ls -R "$INSTALL_PREFIX" || true
            exit 1
          fi

          echo "Using yams binary: $BIN"
          echo "otool -L output:"
          otool -L "$BIN"

          # Check if PDFium is linked - only verify if it's actually linked
          if otool -L "$BIN" | grep -q 'libpdfium'; then
            echo "PDFium detected in binary, verifying @rpath configuration..."
            # Assert that the binary references @rpath/libpdfium.dylib (not absolute path)
            if ! otool -L "$BIN" | grep -q '@rpath/libpdfium.dylib'; then
              echo "ERROR: PDFium is linked but not using @rpath/libpdfium.dylib"
              echo "Found PDFium references:"
              otool -L "$BIN" | grep libpdfium || true
              exit 1
            fi
            echo "✅ PDFium correctly linked with @rpath/libpdfium.dylib"

            # Also verify LC_RPATH contains @loader_path/../lib when PDFium is linked
            if ! otool -l "$BIN" | awk '/LC_RPATH/{flag=1} flag&&/path/{print $2} /LC_/&&$0!~/LC_RPATH/{flag=0}' | grep -q '@loader_path/../lib'; then
              echo "ERROR: @loader_path/../lib not present in LC_RPATH of yams binary (required for PDFium)"
              exit 1
            fi
            echo "✅ LC_RPATH correctly configured for PDFium"

            # Verify libpdfium.dylib has install_name set to @rpath/libpdfium.dylib
            PDF="$INSTALL_PREFIX/lib/libpdfium.dylib"
            if [ -f "$PDF" ]; then
              echo "otool -D for libpdfium.dylib:"
              otool -D "$PDF" || true
              if ! otool -D "$PDF" | grep -q '@rpath/libpdfium.dylib'; then
                echo "ERROR: libpdfium.dylib install_name is not @rpath/libpdfium.dylib"
                exit 1
              fi
              echo "✅ libpdfium.dylib install_name correctly set"
            else
              echo "libpdfium.dylib not found at $PDF, attempting discovery..."
              PDF_ALT=$(find "$INSTALL_PREFIX" -maxdepth 2 -name 'libpdfium.dylib' -print -quit || true)
              if [ -n "$PDF_ALT" ]; then
                echo "Found libpdfium.dylib at: $PDF_ALT"
                if ! otool -D "$PDF_ALT" | grep -q '@rpath/libpdfium.dylib'; then
                  echo "ERROR: libpdfium.dylib install_name is not @rpath/libpdfium.dylib (found at $PDF_ALT)"
                  exit 1
                fi
                echo "✅ libpdfium.dylib install_name correctly set"
              else
                echo "WARNING: libpdfium.dylib not present in install prefix; skipping install_name verification"
              fi
            fi
          else
            echo "ℹ️  PDFium not linked in this build (this is acceptable)"
          fi

      - name: Upload installed prefix
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-install-${{ matrix.os }}
          path: ${{ env.INSTALL_PREFIX }}
          if-no-files-found: error

      - name: Package (CPack)
        shell: bash
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          # Generate default TGZ/ZIP packages if configured
          cpack -G TGZ || true
          cpack -G ZIP || true
          # List generated packages (if any)
          ls -la || true

      - name: Upload packages
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-packages-${{ matrix.os }}
          path: |
            ${{ env.BUILD_DIR }}/*.tar.gz
            ${{ env.BUILD_DIR }}/*.tgz
            ${{ env.BUILD_DIR }}/*.zip
            build/Release/*.tar.gz
            build/Release/*.tgz
            build/Release/*.zip
          if-no-files-found: ignore

      - name: Upload benchmark results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-${{ matrix.os }}
          path: ${{ env.BUILD_DIR }}/bench_results
          if-no-files-found: ignore

      - name: Run retrieval evaluation (fixture)
        shell: bash
        run: |
          set -euo pipefail

          # Locate evaluator binary
          if [ -x "build/Release/tools/eval/yams-eval" ]; then
            EVAL_BIN="build/Release/tools/eval/yams-eval"
          elif [ -x "$BUILD_DIR/tools/eval/yams-eval" ]; then
            EVAL_BIN="$BUILD_DIR/tools/eval/yams-eval"
          elif [ -x "$INSTALL_PREFIX/bin/yams-eval" ]; then
            EVAL_BIN="$INSTALL_PREFIX/bin/yams-eval"
          else
            echo "yams-eval not found; skipping retrieval evaluation."
            exit 0
          fi

          # Locate CLI binary
          if [ -x "build/Release/tools/yams-cli/yams" ]; then
            CLI_BIN="build/Release/tools/yams-cli/yams"
          elif [ -x "$BUILD_DIR/tools/yams-cli/yams" ]; then
            CLI_BIN="$BUILD_DIR/tools/yams-cli/yams"
          elif [ -x "$INSTALL_PREFIX/bin/yams" ]; then
            CLI_BIN="$INSTALL_PREFIX/bin/yams"
          else
            echo "yams CLI not found; skipping retrieval evaluation."
            exit 0
          fi

          # Queries fixture
          QUERIES="yams/paper/data/queries.jsonl"
          if [ ! -f "$QUERIES" ]; then
            echo "Queries fixture not found at $QUERIES; skipping."
            exit 0
          fi

          # Output dir
          OUT_DIR="$BUILD_DIR/eval_results"
          mkdir -p "$OUT_DIR"

          # Run hybrid evaluation
          "$EVAL_BIN" --queries "$QUERIES" --cli "$CLI_BIN" --limit 20 --k 5,10,20 --mode hybrid --output "$OUT_DIR/retrieval_metrics.hybrid.json" || true

          # Run fail-open KG evaluation
          "$EVAL_BIN" --queries "$QUERIES" --cli "$CLI_BIN" --limit 20 --k 5,10,20 --mode fail-open-kg --output "$OUT_DIR/retrieval_metrics.failopen.json" || true

      - name: Upload retrieval metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: retrieval-metrics-${{ matrix.os }}
          path: ${{ env.BUILD_DIR }}/eval_results
          if-no-files-found: ignore

      - name: Upload coverage report
        if: matrix.platform == 'linux' && always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            ${{ env.BUILD_DIR }}/coverage.html
            ${{ env.BUILD_DIR }}/coverage.xml
          if-no-files-found: ignore

      - name: Upload CLI binary (if present)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yams-cli-${{ matrix.os }}
          path: |
            ${{ env.BUILD_DIR }}/tools/yams-cli/yams
            ${{ env.BUILD_DIR }}/tools/yams-cli/Debug/yams
            ${{ env.BUILD_DIR }}/tools/yams-cli/Release/yams
            build/Release/tools/yams-cli/yams
          if-no-files-found: ignore
